"""
Base class for Ansible Actions.
"""

import asyncio
import cli2
import copy
import difflib
import os
import re
import traceback

from ansible.plugins.action import ActionBase
from ansible.plugins.action import display
from ansible.plugins.filter.core import to_nice_yaml

# colors:
# black
# bright gray
# blue
# white
# green
# cyan
# bright green
# red
# bright cyan
# purple
# bright red
# yellow
# bright purple
# dark gray
# magenta
# bright magenta
# normal

# 7-bit C1 ANSI sequences
ansi_escape = re.compile(r'''
    \x1B  # ESC
    (?:   # 7-bit C1 Fe (except CSI)
        [@-Z\\-_]
    |     # or [ for CSI, followed by a control sequence
        \[
        [0-?]*  # Parameter bytes
        [ -/]*  # Intermediate bytes
        [@-~]   # Final byte
    )
''', re.VERBOSE)


UNSET_DEFAULT = '__UNSET__DEFAULT__'


class Option:
    """
    Ansible Option descriptor.

    .. py:attribute:: arg

        Name of the task argument to get this option value from

    .. py:attribute:: fact

        Name of the fact, if any, to get a value for this option if no task arg
        is provided

    .. py:attribute:: default

        Default value, if any, in case neither of arg and fact were defined.
    """
    UNSET_DEFAULT = UNSET_DEFAULT

    def __init__(self, arg=None, fact=None, default=UNSET_DEFAULT):
        self.arg = arg
        self.fact = fact
        self.default = default

    @property
    def kwargs(self):
        kwargs = dict(default=self.default)
        if self.arg:
            kwargs['arg_name'] = self.arg
        if self.fact:
            kwargs['fact_name'] = self.fact
        return kwargs

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        try:
            return obj.get(**self.kwargs)
        except AttributeError:
            raise AnsibleOptionError(self)


class AnsibleError(Exception):
    pass


class AnsibleOptionError(AnsibleError):
    def __init__(self, option):
        self.option = option
        super().__init__(option.kwargs)

    @property
    def message(self):
        message = ['Missing']
        if self.option.arg:
            message.append(f'arg `{self.option.arg}`')
            if self.option.fact:
                message.append('or')
        if self.option.fact:
            message.append(f'fact `{self.option.fact}`')
        return ' '.join(message)


class ActionBase(ActionBase):
    """
    Base action class

    .. py:attribute:: result

        Result dict that will be returned to Ansible

    .. py:attribute:: task_vars

        The task_vars that the module was called with

    .. py:attribute:: client

        The client object generated by :py:meth:`client_factory` if you
        implement it.

    .. py:attribute:: mask_keys

        Declare a list of keys to mask:

        .. code-block:: python

            class AnsibleModule(ansible.ActionBase):
                mask_keys = ['secret', 'password']

    .. py:attribute:: mask

        :py:class:`~cli2.mask.Mask` object
    """
    masked_keys = Option(fact='mask_keys', default=[])
    masked_values = Option(fact='mask_values', default=[])
    mask_keys = None

    def get(self, arg_name=None, fact_name=None, default=UNSET_DEFAULT):
        if arg_name and arg_name in self._task.args:
            return self._task.args[arg_name]
        if fact_name and fact_name in self.task_vars:
            return self.task_vars[fact_name]
        if default != UNSET_DEFAULT:
            return default
        if fact_name:
            raise AttributeError(f'Undefined {arg_name} or {fact_name}')
        else:
            raise AttributeError(f'Undefined arg {arg_name}')

    def run(self, tmp=None, task_vars=None):
        self.tmp = tmp
        self.task_vars = task_vars
        self.result = super().run(tmp, task_vars)
        asyncio.run(self.run_wrapped_async())
        return self.result

    def mask_init(self):
        # use ansible template value renderer
        self.mask.renderer = lambda value: self._templar.template(value)

        keys = self.masked_keys + (self.mask_keys or [])
        for key in keys:
            self.mask.keys.add(key)

            # discover values from facts
            if value := self.task_vars.get(key, None):
                self.mask.values.add(value)

            # discover value from args
            if value := self._task.args.get(key, None):
                self.mask.values.add(value)

        # discover values to mask
        for value in self.masked_values:
            if value:
                self.mask.values.add(value)

    async def run_wrapped_async(self):
        self.verbosity = self.task_vars.get('ansible_verbosity', 0)

        if 'LOG_LEVEL' not in os.environ and 'DEBUG' not in os.environ:
            if self.verbosity == 1:
                os.environ['LOG_LEVEL'] = 'INFO'
            elif self.verbosity >= 2:
                os.environ['LOG_LEVEL'] = 'DEBUG'
            cli2.configure()

        try:
            try:
                self.client = await self.client_factory()
            except NotImplementedError:
                self.client = None
                self.mask = cli2.Mask()
            else:
                self.mask = copy.deepcopy(self.client.mask)
            self.mask_init()
            await self.run_async()
        except Exception as exc:
            self.result['failed'] = True

            if self.verbosity:
                traceback.print_exc()

            if isinstance(exc, AnsibleError):
                self.result['error'] = exc.message
            elif isinstance(exc, cli2.ResponseError):
                self.result.update(dict(
                    method=exc.method,
                    url=exc.url,
                    status_code=exc.status_code,
                ))
                key, value = self.client.response_log_data(exc.response)
                if key:
                    self.result[f'response_{key}'] = value
                key, value = self.client.request_log_data(exc.request)
                if key:
                    self.result[f'request_{key}'] = value

            # for pytest to raise
            self.exc = exc
        finally:
            if self.mask and self.verbosity:
                self.print_yaml(self.result)

            if (
                self._before_data != UNSET_DEFAULT
                and self._after_data != UNSET_DEFAULT
            ):
                diff = difflib.unified_diff(
                    to_nice_yaml(
                        self.mask(self._before_data)
                    ).splitlines(),
                    to_nice_yaml(
                        self.mask(self._after_data)
                    ).splitlines(),
                    self._before_label,
                    self._after_label,
                )
                cli2.diff(diff)

    def print_yaml(self, data):
        """
        Render data as masked yaml.
        """
        data = self.mask(data)
        yaml = to_nice_yaml(data)
        rendered = cli2.yaml_highlight(yaml)
        self.print(rendered)

    def print(self, data):
        # this serves for mocking
        print(data)

    async def run_async(self):
        """
        The method you are supposed to implement.

        It should:

        - provision the :py:attr:`result` dict
        - find task_vars in :py:attr:`task_vars`
        """

    async def client_factory(self):
        """
        Return a client instance.

        :raise NotImplementedError: By default
        """
        raise NotImplementedError()

    @classmethod
    async def run_test_async(cls, args=None, facts=None, client=None,
                             fail=False):
        """
        Test run the module in a mocked context.

        :param args: Dict of task arguments
        :param facts: Dict of play facts
        :param client: Client instance, overrides the factory
        :param fail: Allow this test to fail without exception
        """
        from unittest import mock
        from ansible.template import Templar
        from ansible.parsing.dataloader import DataLoader
        loader = DataLoader()
        obj = cls(
            task=mock.Mock(),
            connection=mock.Mock(),
            play_context=mock.Mock(),
            loader=loader,
            templar=Templar(loader, variables=facts),
            shared_loader_obj=mock.Mock(),
        )
        obj.tmp = None
        obj.result = dict()
        obj._task.args = args or {}
        obj.task_vars = facts or {}
        obj.task_vars.setdefault('ansible_verbosity', 2)
        obj.exc = False
        obj.masked_values = []
        if client:
            async def _factory():
                return client
            obj.client_factory = _factory
        old = obj.client_factory

        async def set_tries():
            client = await old()
            client.handler.tries = 0
            return client
        obj.client_factory = set_tries
        await obj.run_wrapped_async()
        if obj.exc and not fail:
            raise obj.exc
        if obj.result.get('failed', False) and not fail:
            raise Exception('Module failed, and fail is not True {obj.result}')
        return obj

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._before_data = UNSET_DEFAULT
        self._after_data = UNSET_DEFAULT

    def before_set(self, data, label='before'):
        """
        Set the data we're going to display the diff for at the end.

        :param data: Dictionnary of data
        :param label: Label to show in diff
        """
        self._before_data = data
        self._before_label = label

    def after_set(self, data, label='after'):
        """
        Set the data we're going to display the diff for at the end.

        :param data: Dictionnary of data
        :param label: Label to show in diff
        """
        self._after_data = data
        self._after_label = label

    def subprocess_remote(self, cmd, **kwargs):
        """
        Execute a shell command on the remote in a masked context

        :param cmd: Command to run
        :param kwargs: Other shell args, such as creates etc
        """
        new_task = self._task.copy()
        new_task.args = dict(_raw_params=cmd, **kwargs)
        if self.verbosity:
            display.display(
                f'<{self.task_vars["inventory_hostname"]}> + '
                + self.mask(cmd),
                color='blue',
            )
        shell_action = self._shared_loader_obj.action_loader.get(
            'ansible.builtin.shell',
            task=new_task,
            connection=self._connection,
            play_context=self._play_context,
            loader=self._loader,
            templar=self._templar,
            shared_loader_obj=self._shared_loader_obj,
        )
        result = shell_action.run(task_vars=self.task_vars.copy())

        if self.verbosity:
            if 'stderr_lines' in result:
                self.print(self.mask(result['stderr']))
            if 'stdout_lines' in result:
                self.print(self.mask(result['stdout']))

        result.pop('invocation')
        return result

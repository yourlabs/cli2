import asyncio
import subprocess
from pathlib import Path

import pytest
from code2.diff import parse_unified_diff, reconstruct_unified_diff

@pytest.fixture
def sample_diff():
    # A diff generated for a new file (from /dev/null).
    # The header incorrectly states "+1,11" while there are actually 12 lines.
    diff_text = (
        "--- /dev/null\r\n"
        "+++ hello_world_1743684790.py\r\n"
        "@@ -0,0 +1,11 @@\r\n"
        "+import sys\r\n"
        "+\r\n"
        "+def hello_world(message=None):\r\n"
        "+    if message is None:\r\n"
        "+        if len(sys.argv) > 1:\r\n"
        "+            message = sys.argv[1]\r\n"
        "+        else:\r\n"
        "+            message = \"Default Message\"\r\n"
        "+    print(f\"Hello, World!\\n{message}\")\r\n"
        "+\r\n"
        "+if __name__ == \"__main__\":\r\n"
        "+    hello_world()\r\n"
    )
    return diff_text

def test_parser_and_reconstruction(sample_diff):
    # Parse the diff (it should convert CRLF to LF internally)
    parsed = parse_unified_diff(sample_diff)
    # Check that file names are parsed correctly.
    assert parsed.old_filename == "/dev/null"
    assert parsed.new_filename == "hello_world_1743684790.py"
    # There should be one hunk.
    assert len(parsed.hunks) == 1
    hunk = parsed.hunks[0]
    # For a new file diff, there are no lines from the old file.
    assert hunk.old_count == 0
    # Recalculation fixes the new_count to match the actual number of added lines.
    # In this case, there are 12 lines, so new_count should be 12.
    assert hunk.new_count == 12

    # Reconstruct the diff and check that it uses LF newlines.
    reconstructed = reconstruct_unified_diff(parsed)
    assert "\r\n" not in reconstructed
    # Check that the reconstructed hunk header has the fixed count.
    assert "@@ -0,0 +1,12 @@" in reconstructed

def test_patch_application(tmp_path, sample_diff):
    """
    Create a temporary file, apply a patch generated by our parser/reconstructor,
    and verify that the file is updated as expected.
    """
    # Create a temporary directory structure.
    target_file = tmp_path / "hello_world_1743684790.py"
    # Write an empty file (simulating /dev/null for a new file).
    target_file.write_text("")

    # Parse the diff (which is in Windows CRLF format) and reconstruct it (using Unix LF).
    parsed = parse_unified_diff(sample_diff)
    fixed_diff = reconstruct_unified_diff(parsed)

    # Write the reconstructed diff to a temporary diff file.
    diff_file = tmp_path / "patch.diff"
    diff_file.write_text(fixed_diff)

    # Apply the patch using the patch command.
    process = subprocess.run(
        ["patch", str(target_file), str(diff_file)],
        capture_output=True,
        text=True,
        cwd=tmp_path
    )

    # Ensure that patch applied successfully.
    assert process.returncode == 0, f"Patch failed: {process.stderr}"

    # Verify that the target file now has the patched content.
    expected = (
        "import sys\n"
        "\n"
        "def hello_world(message=None):\n"
        "    if message is None:\n"
        "        if len(sys.argv) > 1:\n"
        "            message = sys.argv[1]\n"
        "        else:\n"
        "            message = \"Default Message\"\n"
        "    print(f\"Hello, World!\\n{message}\")\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    hello_world()\n"
    )
    new_content = target_file.read_text()
    assert new_content == expected, f"Patched content did not match expected. Got: {new_content}"

@pytest.mark.asyncio
async def test_patch_application_async(tmp_path, sample_diff):
    """
    Asynchronously apply the patch using asyncio.create_subprocess_exec to
    mimic the scenario in which process.communicate() was used.
    """
    target_file = tmp_path / "hello_world_1743684790.py"
    target_file.write_text("")

    parsed = parse_unified_diff(sample_diff)
    fixed_diff = reconstruct_unified_diff(parsed)

    diff_file = tmp_path / "patch.diff"
    diff_file.write_text(fixed_diff)

    process = await asyncio.create_subprocess_exec(
        'patch',
        '-u',
        str(target_file),
        str(diff_file),
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        stdin=asyncio.subprocess.PIPE,
        cwd=str(tmp_path)
    )
    stdout, stderr = await process.communicate(input=fixed_diff.encode('utf8'))

    assert process.returncode == 0, f"Patch failed: {stderr.decode()}"
    expected = (
        "import sys\n"
        "\n"
        "def hello_world(message=None):\n"
        "    if message is None:\n"
        "        if len(sys.argv) > 1:\n"
        "            message = sys.argv[1]\n"
        "        else:\n"
        "            message = \"Default Message\"\n"
        "    print(f\"Hello, World!\\n{message}\")\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    hello_world()\n"
    )
    new_content = target_file.read_text()
    assert new_content == expected, f"Patched content did not match expected. Got: {new_content}"

